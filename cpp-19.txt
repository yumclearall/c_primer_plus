arr[][5];	//空的方括号表示指针
int sum(int arr[3][4], int rows);	//有效声明，但是3会被忽略
					//只能省略左边（最左一个），不能省略右边，无法计算指针长度

typedef int arr4[4];			//arr4是一个内含4个int的数组
typedef arr4 arr3x4[3];		//arr3x4是一个内含4个int的数组
int sum2(arr3x4 ar, int rows);	//与下面声明相同
int sum2(ar[3][4] , int rows);	//与下面声明相同
int sum2(ar[][4] , int rows);	//标准形式

变长数组（VLA）
int sum2(ar[][4] , int rows);	//列数固定，行数随意

c99允许使用变量表示数组的长度
int x = 4;
int y = 5;
double sales[x][y];
边长数组必须是自动存储类别
不能使用static或exren存储类别说明符，变长数组一旦生成就是固定的

c90标准之前数组方框不允许变量

复合字面量
类似数组初始化列表
（int [2]）{10,20}	//复合字面量
创建了一个匿名数组，	可以省略数组大小
(int []){50, 20, 90}		//必须在创建的同时使用他
int *pt1;
pt1 = (int [2]){10, 20};

编译器和程序不会检查下标的有效性
c把数组名解释为该数组首元素的地址
数组和指针关系密切，巴拉巴拉
c传递多维数组的传统方法是把数组名传递给类型匹配的指针形参

字符串
以空字符（\0）结尾的char类型数组

puts();		//只打印字符串，末尾自动加换行符
双引号引起来的内容称为字符常量
字符串内使用双引号，\",加反斜杠转义符
字符串常量属于静态存储类别，只会被存储一次

printf("%s	%p	%c", "we", "are", *"familys");
//we      00000000004B8046        f
%s打印we，%p打印are首字符地址，%c打印familys首字符，（*familys表示其首字符）

printf("%p", "are",);
//00000000004B8046		地址仍然相同，只存一次

末尾没有\0,视为字符数组
确保数组元素至少比字符串多一
所有未被使用的元素都被自动初始化为0，（char形式空字符）
字符数组名是该数组首元素的地址

数组形式和指针形式有何不同

程序载入内存时，也载入了程序中的字符串
字符串存储在静态存储区，
程序在开始运行时才会为数组分配内存
此时，才将字符串拷贝到数组中，
此时字符串有两个副本，一个是在静态内存中的字符串字面量
另一个是储存在字符数组中的字符串
此后编译器便把字符数组名识别为该数组元素首地址（&arr[0]）的别名
arr是个地址常量，不可更改

指针形式（*arr）也使得编译器为字符串在静态存储区预留空间
一旦开始执行程序，他会为指针变量留出一个储存位置，
并把字符串的地址存储在指针变量中，
该变量最初指向字符串首字符，但是他的值可变，++arr将指向第二个字符

字符串字面量被视为const数据
，如果把一个字符串字面量拷贝给一个数组，就可以改变数据

初始化数组把静态存储区的字符串拷贝到数组中，二初始化指针只把字符串的地址拷贝给指针
数组名是常量，指针名是变量









