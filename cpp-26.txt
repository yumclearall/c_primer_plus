
之前的存储类别的共同之处
在确定存储类别后，根据已制定好的内存管理规则
自动选择其作用域和存储期，

动态分配内存
malloc()和free()
用库函数分配和管理内存

malloc()接受一个所需的内存字节数，
匿名内存，不为其赋名，返回动态分配内存块的首字节地址
可以把该地址赋给一个指针变量，并使用指针访问真快内存

指向void的指针，ansi c标注之前被定义为指向char的指针
“通用指针”，通常函数返回值会被强制转为匹配的类型，不会出现匹配问题
，应坚持使用强制类型转换，提高代码可读性
malloc（）分配内存失败，返回空指针

3种创建数组的方法
常量表达式		int a[10][5];
变量表达式		int* a[5] = {balabala};	int a[n];
malloc（）		int* ptf = (int*)malloc(20 * sizeof(int));

free();		释放之前malloc（）分配的内存，只释放其参数指向的内存块

可以使用exit（）函数结束程序；
都在stdlib.h头文件中

calloc()函数，接受两个无符号整数作为参数
第一个字节是所需存储单元数量，第二个是存储单元大小
把块中的所有位都设置为0

存储类别和动态分配内存有何联系
理想化模型
程序把他的内存分为3部分
一部分供具有外部链接，内部链接和无连接的静态变量使用
一部分供自动变量使用
一部分供动态内存分配

静态存储类别所用内存数量在编译时确定，程序结束时销毁

自动存储类别的变量在程序进入变量定义所在块时存在，离开块时消失
这部分内存通常作为栈来处理，创建的变量按顺序加入内存按相反顺序销毁

动态分配的内存在调用malloc是存在，调用free后释放

动态分配内存比常用栈慢，节约内存空间

程序把静态对象，自动对象和动态分配对象分配在不同的地方

ansi c类型限定符
恒常性和易变性
const和volatile
c99新增restrict，用于提高编译器优化
c11新增_Atomic
c11提供可选库stdatomic.h管理，以支持并发设计

const可以多次声明，多余忽略

文件间共享const数据要小心，两个策略
第一，遵循外部变量常用规则，在一个文件中使用定义声明，在其他文件中使用引用式声明
另一种方案，const变量放在一个头文件中，其他文件包含该头文件

volatile限定符告知计算机，代理（e而不是变量所在的程序）可以改变该变量的值
restrict关键字允许编译器优化某部分代码以更好地支持计算，只能用于指针
表明该指针是访问数据对象的唯一初始方式





















